#include "DSP28x_Project.h"     // Device Headerfile and Examples Include File
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Variable_init.h"
#include "AD7762_init.h"
#include "Math_Function.h"

interrupt void XINT1_isr(void);
void Gpio_select(void);

void main(void)
{
	InitSysCtrl();
	DINT;    // Initialize the PIE control registers to their default state.
	InitPieCtrl();  // Disable CPU interrupts and clear all CPU interrupt flags:
	IER = 0x0000;
	IFR = 0x0000;
	InitPieVectTable();  // Initialize the PIE vector table with pointers to the shell Interrupt
//	init_zone0();    //初始化zone0    原来程序中应对应的是AD
	Xcorr_refdata();
	Gpio_select();
	InitEPwm2Gpio();
	GPIO3_PWM_Init(1152); //GPIO3的PWM初始化.1.152MHz采样率为18kHz
	//	GPIO3_PWM_Init(2304); //GPIO3的PWM初始化.2.304MHz采样率为36kHz
	GPIO4_XINT_Init(); //XINt1中断初始化
	AD7762_Write(0x0002, 0x0003);        //AD7662控制寄存器2写入0x0003值；
	memset(DATABuf1, 0, BUF_SIZE);
	memset(DATABuf2, 0.0, BUF_SIZE);

	EALLOW;
	PieVectTable.XINT1 = &XINT1_isr;
	PieCtrlRegs.PIECTRL.bit.ENPIE = 1;          // Enable the PIE block
	PieCtrlRegs.PIEIER1.bit.INTx4 = 1;    //使能XINT1的PIE级中断开关
	EDIS;
	IER |= M_INT1; // Enable CPU 第一组中断
	EINT; // Enable Global interrupt INTM
	ERTM; // Enable Global realtime interrupt DBGM

	while(1)
		if(FLAG > 0)
		{
			int16 i;
			FLAG = 0;
			data_cnt = 0;
			ad_signal_num = 0;
			//			AD7762_Write(0x0002, 0x000f);        //AD7662控制寄存器2写入0x0000值,停止AD采集
			DATA_Mean(DATABuf1, BUF_SIZE);
			memset(DATABuf2, 0.0, BUF_SIZE);
			for(i = 0; i < BUF_SIZE; i++)
				DATABuf2[i] =(float32)((float32)(DATABuf1[i])/8388608); //8388608为2^23,整型转化为浮点
			//			DATA_Gate(0x00500000, 16, DATABuf1, DATABuf2);
			memset(DATABuf4, 0.0, BUF_SIZE);
			xcorr(DATABuf3, Block_xcorr, DATABuf2, BUF_SIZE, DATABuf4);
			Piont1 = DATA_Max(DATABuf4, BUF_SIZE);
			//			Piont2 = DATA_Max(DATABuf5, BUF_SIZE);
			//			AD7762_Write(0x0002, 0x0003);        //AD7662控制寄存器2写入0x0003值；
		}
		else
			asm("  NOP");
}


interrupt void XINT1_isr(void)
{
	DINT;
	DRTM;
	PieCtrlRegs.PIEIER1.bit.INTx4 = 0;    //关闭XINT1的PIE级中断开关
	PieCtrlRegs.PIEIFR1.bit.INTx4 = 0;    //XINT1的PIE级中断标志位清零

	if(ad_signal_num > 1023)
	{
		//		AD7762_Write(0x0002, 0x000f);        //AD7662控制寄存器2写入0x0000值,停止AD采集
		FLAG = 10;
		data_cnt = 0;
		ad_signal_num = 0;
	}
	DATABuf1[ad_signal_num] = AD7762_Read();
	data_cnt++;
	ad_signal_num++;

	PieCtrlRegs.PIEIER1.bit.INTx4 = 1;    //XINT1的PIE级中断开关
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1; //PIEACK清0
	ERTM; // Enable Global realtime interrupt DBGM
	EINT;

}


/*--------------------------初始化GPIO---------------------------------*/
void Gpio_select(void)
{
	EALLOW;
	GpioCtrlRegs.GPAMUX1.all = 0x00000000;  // All GPIO    GPIO0~GPIO15
	GpioCtrlRegs.GPAMUX2.all = 0x00000000;  // All GPIO    GPIO16~GPIO31
	GpioCtrlRegs.GPAMUX1.bit.GPIO3=0X0;
	GpioCtrlRegs.GPAMUX1.bit.GPIO4=0X0;
	GpioCtrlRegs.GPAMUX1.bit.GPIO5=0X0;
	GpioCtrlRegs.GPAMUX1.bit.GPIO6=0X0;
	GpioCtrlRegs.GPAMUX1.bit.GPIO7=0X0;
	GpioCtrlRegs.GPBMUX1.all = 0x00000000;  // All GPIO
	GpioCtrlRegs.GPBMUX2.all = 0x00000000; // B ALL GPIO    GPIO48~GPIO63
	GpioCtrlRegs.GPADIR.all = 0xFFFFFFFF;   // All outputs
	GpioCtrlRegs.GPADIR.bit.GPIO7 = 0x0;//DSPIN    IN
	GpioDataRegs.GPADAT.bit.GPIO5 =0x1;    //RESET  UP
	GpioDataRegs.GPADAT.bit.GPIO6 =0x1;    //SYNS  UP

	//    GpioCtrlRegs.GPBDIR.bit.GPIO33 = 0x1;    //SCLA    OUT
	//    GpioCtrlRegs.GPBDIR.bit.GPIO32 = 0x1;    //SDAA    OUT
	//    GpioCtrlRegs.GPBDIR.bit.GPIO61 = 0x0;    //BUSY1    IN
	GpioCtrlRegs.GPBDIR.bit.GPIO36 = 0x1;    //CS    OUT
	GpioCtrlRegs.GPADIR.bit.GPIO3  =0X1;     //MCLK     OUT
	GpioCtrlRegs.GPADIR.bit.GPIO4  =0x0;      //DRDY    IN
	//    GpioCtrlRegs.GPADIR.bit.GPIO10 =0X0;    //I/O    (DS1302)    IN
	GpioCtrlRegs.GPADIR.bit.GPIO5 =0x1;     //RESET    OUT
	GpioCtrlRegs.GPADIR.bit.GPIO31 =0x1;     //RD/WR  OUT
	//    GpioCtrlRegs.GPADIR.bit.GPIO12 =0X1;    //CE    (DS1302)    OUT
	GpioCtrlRegs.GPADIR.bit.GPIO6 =0x1;     //SYNC   OUT
	GpioCtrlRegs.GPCMUX1.all = 0x00000000;  // All GPIO
	GpioCtrlRegs.GPCMUX2.all = 0x00000000;  // All GPIO
	GpioCtrlRegs.GPCDIR.all = 0x00000000;    //GPIOC   ALL INPUT
	//    GpioCtrlRegs.GPBDIR.bit.GPIO60 = 0x1;    //CS1    OUT
	GpioCtrlRegs.GPADIR.bit.GPIO3 = 0x1;     //MCLK     OUT
	GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 0x1;     //MCLK  PWM
	/*
	 * 后面添加的GPIO4作为中断输入
	 */
	GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 0; //选择GPIO4是GPIO口
	GpioCtrlRegs.GPADIR.bit.GPIO4 = 0;//选择GPIO4都是输入口
	GpioCtrlRegs.GPAQSEL1.bit.GPIO4= 0;//GPIO4时钟和系统时钟一样且支持GPIO
	GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 4;//外部中断1选择GPIO4
	XIntruptRegs.XINT1CR.bit.POLARITY= 0;//触发模式为下降沿触发
	XIntruptRegs.XINT1CR.bit.ENABLE = 1;//使能中断
	EDIS;
}
