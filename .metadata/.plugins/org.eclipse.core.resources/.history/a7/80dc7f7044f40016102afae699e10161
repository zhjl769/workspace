/*
 * AD7762_init.h
 *
 *  Created on: 2016-11-25
 *      Author: zhjl769
 */

#ifndef AD7762_INIT_H_
#define AD7762_INIT_H_



void delay_N_Iclk(unsigned long Num)
{
	unsigned long i;
	for (i = 0; i < Num; i++)
	{
		asm("  NOP");
	}
}

void GPIO4_XINT_Init(void)
{

	EALLOW;
	PieCtrlRegs.PIECTRL.bit.ENPIE = 1;    //使能PIE中断开关
	PieCtrlRegs.PIEIER1.bit.INTx4 = 1;    //使能XINT1的PIE级中断开关
	IER |= M_INT1; // Enable CPU 第一组中断
	GpioCtrlRegs.GPAMUX1.bit.GPIO4 = 0; //选择GPIO4是GPIO口
	GpioCtrlRegs.GPADIR.bit.GPIO4 = 0;//选择GPIO4都是输入口
	GpioCtrlRegs.GPAQSEL1.bit.GPIO4= 0;//GPIO4时钟和系统时钟一样且支持GPIO
	GpioIntRegs.GPIOXINT1SEL.bit.GPIOSEL = 4;//外部中断1选择GPIO4
	XIntruptRegs.XINT1CR.bit.POLARITY= 0;//触发模式为下降沿触发
	XIntruptRegs.XINT1CR.bit.ENABLE = 1;//使能中断
	EDIS;
}

void GPIO3_PWM_Init(void)
{
	EALLOW;
	GpioCtrlRegs.GPADIR.bit.GPIO2 = 1;    //设置GPIO2输出方向
	GpioCtrlRegs.GPAMUX1.bit.GPIO2 = 1;   //ePWM2A
	GpioCtrlRegs.GPADIR.bit.GPIO3 = 1;    //设置GPIO3输出方向
	GpioCtrlRegs.GPAMUX1.bit.GPIO3 = 1;   //ePWM2B
	EDIS;

    ///////////////////////////////////////////////////////////////////
	//时间基准寄存器
	EPwm2Regs.TBPRD = 7499;             // Period = 7499+1 个TB时钟周期
	EPwm2Regs.TBPHS.all = 0;            // 相位为零
	EPwm2Regs.TBCTR = 0;                  //计数器初始值为零

	// Set Compare values
	EPwm2Regs.CMPA.half.CMPA = 2000;
	EPwm2Regs.CMPB = 4000;

	//设置TBCLK=120M/2=30M
	EPwm2Regs.TBCTL.bit.HSPCLKDIV = 0;  //高速时间基准时钟预分频
	EPwm2Regs.TBCTL.bit.CLKDIV = 0;     //时间基准时钟预分频

	EPwm2Regs.TBCTL.bit.CTRMODE = 0;    //增模式

	//设定动作
	EPwm2Regs.AQCTLA.bit.CAU =0x1; //增模式：计数器等于CPMA时ePWMA输出变低
	EPwm2Regs.AQCTLA.bit.PRD =0x2; //增模式：计数器等于周期值时wPWMA输出变高
	EPwm2Regs.AQCTLB.bit.CBU =0x1; //增模式：计数器等于CPMB时ePWMB输出变低
	EPwm3Regs.AQCTLB.bit.PRD =0x2; //增模式：计数器等于周期值时ePWMB输出变高
	///////////////////////////////////////////////////////////////////

	/*
	 // Setup TBCLK
	   EPwm1Regs.TBPRD = EPWM_TIMER_TBPRD;           // Set timer period 1500/2 TBCLKs
	   EPwm1Regs.TBPHS.half.TBPHS = 0x0000;           // Phase is 0
	   EPwm1Regs.TBCTR = 0x0000;                      // Clear counter



	   // Set Compare values
	   EPwm1Regs.CMPA.half.CMPA = EPWM_CMPAB;     // Set compare A value
	//   EPwm1Regs.CMPB = EPWM_CMPAB;               // Set Compare B value

	   // Setup counter mode
	   EPwm1Regs.TBCTL.bit.CTRMODE = TB_COUNT_UPDOWN; // Count up down

	   EPwm1Regs.TBCTL.bit.PHSEN = TB_ENABLE;        // enable phase loading   use for sync
	   EPwm1Regs.TBCTL.bit.PHSDIR=TB_UP;
	   EPwm1Regs.TBCTL.bit.SYNCOSEL=TB_SYNC_IN;

	   EPwm1Regs.TBCTL.bit.HSPCLKDIV = TB_DIV2+TB_DIV4+TB_DIV4;       // TBClock ratio = SYSCLKOUT/(2*HSPCLKDIV*
	   EPwm1Regs.TBCTL.bit.CLKDIV = TB_DIV1;        //                          2^CLKDIV)

	   // Setup shadowing
	   EPwm1Regs.CMPCTL.bit.SHDWAMODE = CC_SHADOW;
	//   EPwm1Regs.CMPCTL.bit.SHDWBMODE = CC_SHADOW;
	   EPwm1Regs.CMPCTL.bit.LOADAMODE = CC_CTR_ZERO;  // Load on Zero
	 //  EPwm1Regs.CMPCTL.bit.LOADBMODE = CC_CTR_ZERO;


	   // Set actions
	   EPwm1Regs.AQCTLA.bit.CAU = AQ_SET;             // Set PWM1A on event A, up count
	   EPwm1Regs.AQCTLA.bit.CAD = AQ_CLEAR;           // Clear PWM1A on event A, down count

	  // EPwm1Regs.AQCTLB.bit.CAU = AQ_CLEAR;             //Clear  PWM1B on event A, up count
	  // EPwm1Regs.AQCTLB.bit.CAD = AQ_SET;           //  Set PWM1B on event A, down count

	   // Set DeadBand
	   EPwm1Regs.DBCTL.bit.IN_MODE=DBA_ALL;
	   EPwm1Regs.DBCTL.bit.POLSEL=DB_ACTV_HIC;
	   EPwm1Regs.DBCTL.bit.OUT_MODE=DB_FULL_ENABLE;
	   EPwm1Regs.DBRED=Dbred;                       // Dead-band rising edge delay
	   EPwm1Regs.DBFED=Dbfed;                       // Dead-band falling edge delay

	   // Set Trip Zone
	   EPwm1Regs.TZSEL.bit.OSHT1=TZ_ENABLE;
	   EPwm1Regs.TZCTL.bit.TZA=TZ_FORCE_LO;
	   EPwm1Regs.TZCTL.bit.TZB=TZ_FORCE_LO;


	   // Interrupt where we will change the Compare Values
	   EPwm1Regs.ETSEL.bit.SOCBSEL= ET_CTR_ZERO;      // Select start ADC (EPWMxSOCB) on Zero event
	   EPwm1Regs.ETSEL.bit.SOCBEN= Enable;                 // Enable
	   EPwm1Regs.ETPS.bit.SOCBPRD=ET_1ST;


	///////////////////////////////////////////////////////////////////
	//时间基准寄存器
	EPwm2Regs.TBPRD = 7499;             // Period = 7499+1 个TB时钟周期
	EPwm2Regs.TBPHS.all = 0;            // 相位为零
	EPwm2Regs.TBCTR=0;                  //计数器初始值为零

	EPwm2Regs.CMPA.half.CMPA = 2000;
	EPwm2Regs.CMPB = 4000;

	//设置TBCLK=120M/2=60M
	EPwm2Regs.TBCTL.bit.HSPCLKDIV = 0;  //高速时间基准时钟预分频
	EPwm2Regs.TBCTL.bit.CLKDIV = 0;     //时间基准时钟预分频
	EPwm2Regs.TBCTL.bit.CTRMODE = 0;    //增模式

	//设定动作
	EPwm2Regs.AQCTLA.bit.CAU = 0x1; //增模式：计数器等于CPMA时ePWMA输出变低
	EPwm2Regs.AQCTLA.bit.PRD = 0x2; //增模式：计数器等于周期值时wPWMA输出变高
	EPwm2Regs.AQCTLB.bit.CBU = 0x1; //增模式：计数器等于CPMB时ePWMB输出变低
	EPwm2Regs.AQCTLB.bit.PRD = 0x2; //增模式：计数器等于周期值时ePWMB输出变高
	////////////////////////////////////////////////////////////////// */
}



void AD7762_Write(int16 reg_addr, int16 reg_number)
{
	int16 tmp1 = 0x0000,tmp2 = 0x0000;
	tmp1 =
			((reg_addr&0x0001)<<15)|((reg_addr&0x0002)<<13)|((reg_addr&0x0004)<<11)
			|((reg_addr&0x0008)<<9)|((reg_addr&0x0010)<<7)|((reg_addr&0x0020)<<5)
			|((reg_addr&0x0040)<<3)|((reg_addr&0x0080)<<1)|((reg_addr&0x0100)>>1)
			|((reg_addr&0x0200)>>3)|((reg_addr&0x0400)>>5)|((reg_addr&0x0800)>>7)
			|((reg_addr&0x1000)>>9)|((reg_addr&0x2000)>>11)|((reg_addr&0x4000)>>13)|((reg_addr&0x8000)>>15);
	tmp2 =
			((reg_number&0x0001)<<15)|((reg_number&0x0002)<<13)|((reg_number&0x0004)<<11)
			|((reg_number&0x0008)<<9)|((reg_number&0x0010)<<7)|((reg_number&0x0020)<<5)
			|((reg_number&0x0040)<<3)|((reg_number&0x0080)<<1)|((reg_number&0x0100)>>1)
			|((reg_number&0x0200)>>3)|((reg_number&0x0400)>>5)|((reg_number&0x0800)>>7)
			|((reg_number&0x1000)>>9)|((reg_number&0x2000)>>11)|((reg_number&0x4000)>>13)|((reg_number&0x8000)>>15);
	EALLOW;
	GpioDataRegs.GPADAT.bit.GPIO5=0x1;    //拉高RESET
	delay_N_Iclk(100);
	GpioDataRegs.GPADAT.bit.GPIO5=0x0;    //延时8.3us后拉低RESET(从那看出延迟了6.6us,延迟1000隔指令周期？)
	delay_N_Iclk(100);
	GpioDataRegs.GPADAT.bit.GPIO5=0x1;    //保持8.3us后拉高RESET    中间延时的时间间隔可否再短一些，提高执行速度
	delay_N_Iclk(500);
	GpioCtrlRegs.GPCMUX1.all=0x0000;   //GPIO79-64作为GPIO口
	GpioCtrlRegs.GPCDIR.all = 0xffff;   // GPIO79-64作为 outputs
	GpioDataRegs.GPCDAT.all =0x0000;    //GPIO79-64作为0
	GpioCtrlRegs.GPCPUD.all = 0xffff;   //上拉电阻使能
	delay_N_Iclk(500);
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	GpioDataRegs.GPADAT.bit.GPIO31=0x1;    //RD/WD 拉高
	delay_N_Iclk(3500);
	GpioDataRegs.GPCDAT.all |= tmp1;    //reg_addr寄存器地址赋予GPIO79-64；
	delay_N_Iclk(500);
	GpioDataRegs.GPBDAT.bit.GPIO36=0x0;    //CS 拉低
	delay_N_Iclk(3500);
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	GpioDataRegs.GPCDAT.all =0x0000;    //GPIO79-64作为0
	delay_N_Iclk(3500);
	GpioDataRegs.GPCDAT.all |= tmp2;    //reg_number寄存器值赋予GPIO79-64；
	delay_N_Iclk(3500);
	GpioDataRegs.GPBDAT.bit.GPIO36=0x0;    //CS 拉低
	delay_N_Iclk(3500);
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	GpioDataRegs.GPCDAT.all =0x0000;    //GPIO79-64作为0
	delay_N_Iclk(3500);
	GpioCtrlRegs.GPCDIR.all = 0x0000;   // GPIO79-64作为 intputs
	GpioCtrlRegs.GPCMUX1.all = 0x0000;   //GPIO79-64作为GPIO口
	GpioCtrlRegs.GPCDIR.all = 0x0000;   // GPIO79-64作为inputs
	GpioDataRegs.GPCDAT.all = 0x0000;    //GPIO79-64作为0
	GpioCtrlRegs.GPCPUD.all = 0xffff;   //上拉电阻使能
	GpioDataRegs.GPADAT.bit.GPIO31=0x1;    //RD/WD 拉高
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	delay_N_Iclk(3500);
	EDIS;
}

int32 AD7762_Read(void)
{
	int32 tmp = 0x00000000;
	int16 tmp1 = 0x0000,tmp2 = 0x0000;
	EALLOW;
	//	GpioCtrlRegs.GPCMUX1.all = 0x0000;   //GPIO79-64作为GPIO口
	//	GpioCtrlRegs.GPCDIR.all = 0x0000;   // GPIO79-64作为inputs
	//	GpioDataRegs.GPCDAT.all = 0x0000;    //GPIO79-64作为0
	//	GpioCtrlRegs.GPCPUD.all = 0xffff;   //上拉电阻使能
	//	GpioDataRegs.GPADAT.bit.GPIO31=0x1;    //RD/WD 拉高
	//	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	GpioDataRegs.GPADAT.bit.GPIO31=0x0;    //RD/WD 拉低
	GpioDataRegs.GPBDAT.bit.GPIO36=0x0;    //CS 拉低
	delay_N_Iclk(5);
	tmp1 |= GpioDataRegs.GPCDAT.all;    //GPIO79-64的值赋予tmp1；
	delay_N_Iclk(5);
	GpioDataRegs.GPADAT.bit.GPIO31=0x1;    //RD/WD 拉高
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	delay_N_Iclk(5);
	GpioDataRegs.GPADAT.bit.GPIO31=0x0;    //RD/WD 拉低
	GpioDataRegs.GPBDAT.bit.GPIO36=0x0;    //CS 拉低
	delay_N_Iclk(5);
	tmp2 |= GpioDataRegs.GPCDAT.all;    //GPIO79-64的值赋予tmp1；
	delay_N_Iclk(5);
	GpioDataRegs.GPADAT.bit.GPIO31=0x1;    //RD/WD 拉高
	GpioDataRegs.GPBDAT.bit.GPIO36=0x1;    //CS 拉高
	EDIS;

	tmp1 =
			((tmp1&0x0001)<<15)|((tmp1&0x0002)<<13)|((tmp1&0x0004)<<11)
			|((tmp1&0x0008)<<9)|((tmp1&0x0010)<<7)|((tmp1&0x0020)<<5)
			|((tmp1&0x0040)<<3)|((tmp1&0x0080)<<1)|((tmp1&0x0100)>>1)
			|((tmp1&0x0200)>>3)|((tmp1&0x0400)>>5)|((tmp1&0x0800)>>7)
			|((tmp1&0x1000)>>9)|((tmp1&0x2000)>>11)|((tmp1&0x4000)>>13)|((tmp1&0x8000)>>15);

	tmp2 =
			((tmp2&0x0001)<<15)|((tmp2&0x0002)<<13)|((tmp2&0x0004)<<11)
			|((tmp2&0x0008)<<9)|((tmp2&0x0010)<<7)|((tmp2&0x0020)<<5)
			|((tmp2&0x0040)<<3)|((tmp2&0x0080)<<1)|((tmp2&0x0100)>>1)
			|((tmp2&0x0200)>>3)|((tmp2&0x0400)>>5)|((tmp2&0x0800)>>7)
			|((tmp2&0x1000)>>9)|((tmp2&0x2000)>>11)|((tmp2&0x4000)>>13)|((tmp2&0x8000)>>15);

	tmp |= tmp1;
	tmp &= 0x0000ffff;
	tmp <<= 8;
	tmp |= ((tmp2 >>8) & 0x00ff);
	return tmp1;
}

#endif /* AD7762_INIT_H_ */
